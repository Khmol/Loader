
// xtea.c
// https://ru.wikipedia.org/wiki/XTEA

/*    Сравнение различных версий расширения XTEA
  Первый алгоритм (XTEA-1) имеет наибольшую скорость и при достаточном количестве 
  раундов (от 32 до 64) обладает хорошей надежностью. XTEA-2 представляет собой 
  расширение с большим размером блока, и он не более защищен чем XTEA-1. 
  XTEA-3 — это расширение алгоритм с использованием большего размера блока и 
  ключа. Третий вариант работает немного медленнее, но более защищен. Так как 
  эти алгоритмы построены на базе оригинального TEA с устранением всех известных 
  недостатков, то их можно считать достаточно надежными.
  Сравнительная таблица алгоритмов:
      Название | Мин. кол-во | Макс. кол-во | Размер  |  Размер 
               |   раундов	 |    раундов	  |  блока  |  ключа
      -----------------------------------------------------------
        XTEA-1 |     32	     |      64	    | 64 бита	|  128 бит
        XTEA-2 |     64	     |     128	    | 128 бит	|  128 бит
        XTEA-3 |     64	     |     128	    | 128 бит	|  256 бит

  Алгоритмы могут быть доработаны. Первая проблема состоит в том, только младшие 
  биты открытого текста используются для циклического битового сдвига ключа 
  (как в XTEA-1 и XTEA-2). Вторая проблема заключается в том что ключ разделен 
  на две подгруппы по 4 элемента, и каждая часть выражения использует только 
  одну подгруппу (как в XTEA-3). XTEA-3 может быть расширен путём использования 
  всех восьми элементов в обеих частях выражения.
*/

#include "xtea.h"


// *****************************************************************************
// ************** А л г о р и т м * X T E A - 1 ********************************
// Одна из уязвимостей XTEA состоит в том, что биты в ключе влияют на одни и те 
// же биты в каждом раунде алгоритма. Эта проблема может быть устранена путём 
// использования шифра, включающего в себя алгоритм расписания ключей. 
// Планирование ключей производится динамически и не требует выделения памяти. 
// Расписание ключей осуществляется путём циклического битового сдвига ключа на 
// значение, зависящее от открытого текста. Алгоритм XTEA-1 реализует эту идею 
// по усилению шифра XTEA путём незначительного изменения структуры шифра без 
// изменения основных принципов алгоритма.
// Шифр использует технологию забеливания и зависимую от данных трансформацию 
// подключа, что затрудняет криптоанализ, поскольку исходный алгоритм содержал 
// уязвимость — модификация определенных бит ключа отражалась на соответствующих 
// им битах шифротекста.

// *****************************************************************************
// Выполняет циклический битовый сдвиг ключа, используя 5 младших битов 
// переменной shift. Этот алгоритм использует только один сдвиг за раунд, что 
// довольно эффективно и быстро работает на большинстве современных процессорах
static inline uint32_t rol(uint32_t base, uint32_t shift)
{
  // only 5 bits of shift are significant
  shift &= 0x1F;
  uint32_t res = (base << shift) | (base >> (32 - shift));
  return res;
}


// *****************************************************************************
// Зашифровать по алгоритму XTEA-1
// [num_rounds] - Кол-во раундов (32 - 64)
// [*pData]     - Указатель на данные (2 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (4 значения по 32 бита)
void xtea1_encipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
  uint32_t delta = 0x9E3779B9;
	uint32_t sum = 0;
	
  // load and pre-white the registers
	uint32_t y = pData[0] + pKey[0];
	uint32_t z = pData[1] + pKey[1];
	
  // Round functions
	for(uint32_t i = 0; i < num_rounds; i++) 
	{
		y += ((z << 4) ^ (z >> 5)) + (z ^ sum) + rol(pKey[sum & 3], z);
		sum += delta;
		z += ((y << 4) ^ (y >> 5)) + (y ^ sum) + rol(pKey[(sum >> 11) & 3], y);
	}
  
	// post-white and store registers
	pData[0] = y ^ pKey[2];
	pData[1] = z ^ pKey[3];
  return;
}


// *****************************************************************************
// Расшифровать по алгоритму XTEA-1
// [num_rounds] - Кол-во раундов (32 - 64)
// [*pData]     - Указатель на данные (2 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (4 значения по 32 бита)
void xtea1_decipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
	uint32_t delta = 0x9E3779B9;
  uint32_t sum = delta * num_rounds;
	
  uint32_t z = pData[1] ^ pKey[3];
	uint32_t y = pData[0] ^ pKey[2];
  
	for(uint32_t i = 0; i < num_rounds; i++) 
	{
		z -= ((y << 4) ^ (y >> 5)) + (y ^ sum) + rol(pKey[(sum >> 11) & 3], y);
		sum -= delta;
		y -= ((z << 4) ^ (z >> 5)) + (z ^ sum) + rol(pKey[sum & 3], z);
	}
	
  pData[1] = z - pKey[1];
	pData[0] = y - pKey[0];
  return;
}


// *****************************************************************************
// ************** А л г о р и т м * X T E A - 2 ********************************
// Расширение XTEA-1 — использование 128 битного блока. Полученный алгоритм 
// требует больше раундов, но скорость шифрования у него выше чем у XTEA.
// Основное преимущество этого алгоритма — это возможность шифровать большие 
// блоки. Этот алгоритм использует те же базовые операции что и XTEA-1, но 
// требует больше итераций. На самом деле он требует в два раза больше итераций 
// от 32 до 64 (от 64 до 128 раундов). 48 итераций — это компромисс между 
// скоростью и надежностью шифрования.
// *****************************************************************************

// *****************************************************************************
// Зашифровать по алгоритму XTEA-2
// [num_rounds] - Кол-во раундов (64 - 128)
// [*pData]     - Указатель на данные (4 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (4 значения по 32 бита)
void xtea2_encipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
  uint32_t t;
  uint32_t delta = 0x9E3779B9;
	uint32_t sum = 0;
  
	uint32_t a = pData[0];
	uint32_t b = pData[1] + pKey[0];
	uint32_t c = pData[2];
	uint32_t d = pData[3] + pKey[1];
  
	for(uint32_t i = 0; i < num_rounds; i++) 
  {
		a += ((b << 4) ^ (b >> 5)) + (d ^ sum) + rol(pKey[sum & 3], b);
		sum += delta;
		c += ((d << 4) ^ (d >> 5)) + (b ^ sum) + rol(pKey[(sum >> 11) & 3], d);
		t = a; 
    a = b; 
    b = c; 
    c = d; 
    d = t;
	}
  
	pData[0] = a ^ pKey[2];
	pData[1] = b;
	pData[2] = c ^ pKey[3];
	pData[3] = d;
  return;
}


// *****************************************************************************
// Расшифровать по алгоритму XTEA-2
// [num_rounds] - Кол-во раундов (64 - 128)
// [*pData]     - Указатель на данные (4 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (4 значения по 32 бита)
void xtea2_decipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
	uint32_t t;
  uint32_t delta = 0x9E3779B9;
  uint32_t sum = delta * num_rounds;
  
	uint32_t d = pData[3];
	uint32_t c = pData[2] ^ pKey[3];
	uint32_t b = pData[1];
	uint32_t a = pData[0] ^ pKey[2];
  
	for(uint32_t i = 0; i < num_rounds; i++) 
  {
		t = d; 
    d = c; 
    c = b; 
    b = a; 
    a = t;
		c -= ((d << 4) ^ (d >> 5)) + (b ^ sum) + rol(pKey[(sum >> 11) & 3], d);
		sum -= delta;
		a -= ((b << 4) ^ (b >> 5)) + (d ^ sum) + rol(pKey[sum & 3], b);
	}
  
	pData[0] = a;
	pData[1] = b - pKey[0];
	pData[2] = c;
	pData[3] = d - pKey[1];
  return;
}


// *****************************************************************************
// ************** А л г о р и т м * X T E A - 3 ********************************
// Расширение XTEA-1 — использование 256 битного ключа и более практичного 128 
// битного блока. Этот алгоритм требует от 32 до 64 итераций, но в то же время 
// обеспечивает надежную защиту от атак путём полного перебора. Шифр использует 
// технологию забеливания и реализует операции, зависимые от ключа, что 
// затрудняет криптоанализ.
// XTEA-3 использует 5 старших и 5 младших бит регистра открытого текста для 
// циклического сдвига ключа, потому что статистические данные говорят о том, 
// что эти биты наиболее подвержены изменениию. Этот алгоритм так же требует как 
// минимум 32 итерации, однако, 48 итераций — это компромиссное соотношение 
// между скоростью и надежностью шифрования данных.
// *****************************************************************************

// *****************************************************************************
// Зашифровать по алгоритму XTEA-3
// [num_rounds] - Кол-во раундов (64 - 128)
// [*pData]     - Указатель на данные (4 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (8 значений по 32 бита)
void xtea3_encipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
	uint32_t t;
  uint32_t delta = 0x9E3779B9;
	uint32_t sum = 0;
  
	uint32_t a = pData[0] + pKey[0];
	uint32_t b = pData[1] + pKey[1];
	uint32_t c = pData[2] + pKey[2];
	uint32_t d = pData[3] + pKey[3];
  
	for(uint32_t i = 0; i < num_rounds; i++)
  {
		a += (((b << 4) + rol (pKey[(sum % 4) + 4], b)) ^
          (d + sum) ^ ((b >> 5) + rol (pKey[sum % 4], b >> 27)));
		sum += delta;
    c += (((d << 4) + rol (pKey[((sum >> 11) % 4) + 4], d)) ^
          (b + sum) ^ ((d >> 5) + rol (pKey[(sum >> 11) % 4], d >> 27)));
    t = a;
    a = b;
    b = c;
    c = d;
    d = t;
	}
  
	pData[0] = a ^ pKey[4];
	pData[1] = b ^ pKey[5];
	pData[2] = c ^ pKey[6];
	pData[3] = d ^ pKey[7];
  return;
}


// *****************************************************************************
// Расшифровать по алгоритму XTEA-3
// [num_rounds] - Кол-во раундов (64 - 128)
// [*pData]     - Указатель на данные (4 значения по 32 бита), результат тут
// [*pKey]      - Указатель на ключ шифрования (8 значений по 32 бита)
void xtea3_decipher(uint32_t num_rounds, uint32_t* pData, uint32_t const* pKey)
{
  uint32_t t;
  uint32_t delta = 0x9E3779B9;
  uint32_t sum = delta * num_rounds;
  
	uint32_t d = pData[3] ^ pKey[7];
	uint32_t c = pData[2] ^ pKey[6];
	uint32_t b = pData[1] ^ pKey[5];
	uint32_t a = pData[0] ^ pKey[4];
	
  for(uint32_t i = 0; i < num_rounds; i++)
  {
		t = d;
    d = c;
    c = b;
    b = a;
    a = t;
		c -= (((d << 4) + rol (pKey[((sum >> 11) % 4) + 4], d)) ^
          (b + sum) ^ ((d >> 5) + rol (pKey[(sum >> 11) % 4], d >> 27)));
    sum -= delta;
		a -= (((b << 4) + rol (pKey[(sum % 4) + 4], b)) ^
          (d + sum) ^ ((b >> 5) + rol (pKey[sum % 4], b >> 27)));
  }
  
	pData[3] = d - pKey[3];
	pData[2] = c - pKey[2];
	pData[1] = b - pKey[1];
	pData[0] = a - pKey[0];

  return;
}


// *****************************************************************************
// Тест алгоритма XTEA-3
static void xtea3_test(void)
{
  const uint32_t key[8] = { 0x583a2d21, 0x693a4172, 0x5d493e4f, 0x45787122,
                            0x36363b54, 0x5b7d773c, 0x6e647236, 0x3448343d };

  uint8_t data[121];
  uint8_t data_res[(sizeof(data) / (4 * 4) + 1) * (4 * 4)];
  
  // Массив входных данных
  for(uint32_t i = 0; i < sizeof(data); i++)
    data[i] = 0x20 + i;
 
  // * Зашифровать *
  // Счётчик кол-ва байт для кодирования (= размеру массива)
  uint32_t cnt = sizeof(data);
  // Указатель на массив данных, которорые нужно закодировать (не кратный 
  // величине XTEA3_DATA_MIN)
  uint8_t* pData = data;
  // Указатель на массив результата закодированных данных, (кратный величине 
  // XTEA3_DATA_MIN)
  uint8_t* pData_res = data_res;
  // Указатель на начало данных для кодирования
  uint32_t* pData_res_start = (uint32_t*)pData_res;
  // Цикл кодирования данных, пока есть данные
  while(cnt > XTEA3_DATA_MIN)
  {
    // Скопировать данные для шифрования 1
    PTR_PVAL_WRITE_PVAL_INC2_type(uint32_t, pData_res, pData);
    // Скопировать данные для шифрования 2
    PTR_PVAL_WRITE_PVAL_INC2_type(uint32_t, pData_res, pData);
    // Скопировать данные для шифрования 2
    PTR_PVAL_WRITE_PVAL_INC2_type(uint32_t, pData_res, pData);
    // Скопировать данные для шифрования 2
    PTR_PVAL_WRITE_PVAL_INC2_type(uint32_t, pData_res, pData);
    // Зашифровать по алгоритму XTEA-3
    xtea3_encipher((XTEA3_ROUND_MAX + XTEA3_ROUND_MIN) / 2, pData_res_start, key);
    // Увеличить счётчик обработанных байт
    cnt -= XTEA3_DATA_MIN;
    // Перейти на следующую порцию данных для кодировния
    pData_res_start = (uint32_t*)pData_res;
  }

  // Проверка Счётчик кол-ва байт для кодирования 
  if(cnt != 0)
  { // если != 0, то данные не выровнены по размеру XTEA3_DATA_MIN
    // Цикл копирования оставшихся не выровненых данных
    for(uint32_t i = sizeof(data) - cnt; i < sizeof(data); i++)
      *pData_res++ = *pData++;
    // Цикл дописывания данных константой до выровненого размера
    for(uint32_t i = cnt; i < XTEA3_DATA_MIN; i++)
      *pData_res++ = 0xFF;
    // Зашифровать по алгоритму XTEA-3 (остаток данных)
    xtea3_encipher((XTEA3_ROUND_MAX + XTEA3_ROUND_MIN) / 2, pData_res_start, key);
  }
  
  // * Расшифровать *
  // Указатель на массив результатов
  uint32_t* pData_res1 = (uint32_t*)data_res;
  // Cчётчик раскодированных байт
  cnt = 0;
  // Цикл раскодирования всего массива
  while(cnt < sizeof(data_res))
  {
    // Расшифровать по алгоритму XTEA-3
    xtea3_decipher((XTEA3_ROUND_MAX + XTEA3_ROUND_MIN) / 2, pData_res1, key);
    // Инкрементировать указатель на массив для дальнейшей раскодировки
    pData_res1 += XTEA3_PTR_DATA_INC;
    // Ув. обработанных счётчик байт
    cnt += XTEA3_DATA_MIN;
  }
  return;
}